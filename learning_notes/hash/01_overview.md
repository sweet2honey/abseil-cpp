# absl::Hash 学习笔记（阶段一：总览）

> 目标：先建立“是什么/为什么/何时用”的心智模型，再进入接口与实现。

## 1) 一句话概括
`absl::Hash` 是一个**可扩展的通用哈希框架**：你为自定义类型只需描述“把哪些字段纳入哈希状态”（`AbslHashValue`），而**具体哈希算法与混合策略由框架统一负责并可替换**。

## 2) 它解决什么问题（痛点）
在 C++ 工程里，哈希通常遇到这些问题：
- **扩展成本高**：`std::hash` 往往要写完整算法/特化；组合类型要手写混合。
- **哈希质量不可控**：不同团队写的混合方式差异巨大，容易产生碰撞热点。
- **安全与稳健性**：哈希碰撞攻击/恶意输入导致退化（hash-flooding）。
- **ABI/演进**：一旦对外暴露“哈希值语义”，升级算法会破坏兼容性。

`absl::Hash` 通过“抽象 hash state + 统一 mixing + per-process seed”的方式，把大多数工程问题集中到一个框架内解决。

## 3) 与常见方案对比

| 方案 | 代表 | 优点 | 缺点/限制 | 适用场景 | absl::Hash 相对优势 |
|---|---|---|---|---|---|
| 标准库 | `std::hash<T>` | 生态默认、简单 | 扩展依赖特化/不统一；对组合/容器常需自写混合；哈希值常被误当成稳定语义 | 小型项目/只哈希少量类型 | 扩展点更统一（`AbslHashValue`），混合质量由框架负责 |
| Boost | `boost::hash` / `hash_combine` | 组合工具成熟 | 仍需要显式选择混合策略；可移植/一致性策略由使用者承担 | 依赖 Boost 的项目 | 提供“hash state”概念，支持更强的类型擦除与容器无序哈希 |
| 其他库 | folly / llvm ADT 等 | 各有特点 | 往往绑定特定生态 | 特定平台/框架 | Abseil 强调可移植与通用扩展点 |
| 本组件 | `absl::Hash` | 语义清晰：描述字段→框架混合；支持无序组合；可 type-erasure | 哈希值**不稳定**（跨进程/跨 DSO 不保证一致），不能用于持久化/网络协议 | 大型工程的 hash 容器、hash key、缓存 key（进程内） | 更易维护/升级；减少团队自定义混合错误 |

## 4) 核心特点（记住这 5 条就够用）
- **算法被抽象**：用户不依赖具体哈希算法实现。
- **扩展靠 ADL 的 `AbslHashValue`**：只组合“等价性字段”，避免重复发明混合。
- **结果默认非稳定**：通常可视为“进程内随机化”，并可能在动态库边界不同。
- **支持无序组合**：用于 unordered 容器的 order-independent hashing。
- **有性能优化路径**：对“唯一字节表示”的类型、整数等走快速通道。

## 5) 适用 / 不适用场景（边界很重要）

### 适用
- `absl::flat_hash_map/set`、`std::unordered_*` 等 hash 容器的 key。
- 进程内缓存 key、memoization key（同一进程内有效）。
- 需要大量自定义类型可哈希，且希望规则统一、可审计。

### 不适用（或不推荐）
- 需要**跨进程稳定**的哈希（例如：持久化到磁盘、网络协议字段、日志长期比对）。
- 需要跨动态库边界传递 hash 值做语义（文档明确禁止）。
- 把 hash 值当作加密散列/安全签名（它不是密码学哈希）。

## 6) 关键术语表

| 术语 | 简要解释 | 你需要记住的点 |
|---|---|---|
| hash state（哈希状态） | 哈希算法的中间状态 H | 用户只做 `H::combine(...)`，不关心算法 |
| `AbslHashValue` | ADL 扩展点 | 只组合与 `operator==` 一致的字段 |
| type erasure（类型擦除） | `HashState` 抹去模板参数 H | 适用于 PImpl/虚函数等不能模板化的地方 |
| uniquely represented | “相等⇒字节表示相同”的类型 trait | 可启用字节级优化；误用很危险 |

## 7) 自检问题
- 你是否接受“hash 值不稳定”？如果不接受，应换成什么？（例如固定算法 + 固定 seed）
- 你的类型的 `operator==` 用了哪些字段？`AbslHashValue` 必须一致吗？
- 你是否需要在 PImpl/虚接口里哈希？是否需要 `absl::HashState`？

## 8) 入口与后续阅读路线
- 入口头文件：`absl/hash/hash.h`
- 实现细节（选择策略/优化/seed）：`absl/hash/internal/hash.h`
- 正确性验证工具（可选，基于 gtest）：`absl/hash/hash_testing.h`
- 行为与边界用例：`absl/hash/hash_test.cc`
